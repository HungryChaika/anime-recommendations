const path = require("path");
const { readFile } = require("../utils/fileSystem");

const backup = async (filename, client) => {
	try {
		await client.query(
			`CREATE TABLE IF NOT EXISTS public.anime (
			id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY,
			title character varying(1000),
			type character varying(100),
			episodes_amount smallint,
			status character varying(100),
			genres character varying(100),
			primary_source character varying(100),
			release_date date,
			age_rating smallint,
			episode_duration smallint,
			description text,
			image_url character varying(100),
			constraint pk_anime primary key (id));`
		);

		const queryRes = await client.query(
			`
			select count(*)
			from anime
			`
		);

		if (Number(queryRes.rows[0]?.count) === 0) {
			try {
				const data = await readFile(filename);
				const jsonAnime = JSON.parse(data);

				for (let i = 0; i < jsonAnime.length; i++) {
					const result = await client.query(
						`
						insert into anime
						values (default, $1, $2, $3, $4, $5, $6, to_date($7, 'DD MM YYYY'), $8, $9, $10, $11)
						`,
						[
							jsonAnime[i].anime_title || null,
							jsonAnime[i].anime_type || null,
							Number(jsonAnime[i].anime_episodes) || null,
							jsonAnime[i].anime_status || null,
							jsonAnime[i].anime_genres?.join(",") || null,
							jsonAnime[i].anime_primary_source || null,
							jsonAnime[i].anime_date_release || null,
							Number(jsonAnime[i].age_rating?.split("+")?.[0]) || null,
							jsonAnime[i].duration || null,
							jsonAnime[i].description || null,
							jsonAnime[i].image_url || null,
						]
					);
				}
				console.log("Table anime has been restored");
			} catch (e) {
				console.error(e);
			}
		}
	} catch (e) {
		console.log(e);
	}
};

module.exports = backup;
